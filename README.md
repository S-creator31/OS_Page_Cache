# Page Cache Replacement Algorithm Evaluation: LRU vs. CLOCK-Pro

This project implements and evaluates two page cache replacement algorithms, LRU (Least Recently Used) and CLOCK-Pro, as Linux kernel modules. The performance of each algorithm is measured using a trace-replay methodology, allowing for a direct comparison of their cache hit ratios under various workloads.

# Core Concepts

# LRU (Least Recently Used)

The classic cache algorithm. It evicts the page that has not been accessed for the longest time.

Mechanism: Implemented with a doubly-linked list to track recency.

Weakness: It is highly vulnerable to "scan pollution," where a large, one-time sequential read (like a backup or media scan) can flush all the useful, "hot" data from the cache.

# CLOCK-Pro

A modern, scan-resistant algorithm that approximates LIRS (Low Inter-reference Recency Set).

Mechanism: It differentiates between "hot" (frequently used) and "cold" (recently used) pages. New pages enter as "cold" and are only promoted to "hot" if they are re-accessed. Eviction primarily targets "cold" pages.

Advantage: This mechanism protects the valuable hot pages from being evicted by large, "cold" scans, solving LRU's primary weakness.

# System Architecture

The simulation is built using two independent Linux Kernel Modules (lru_cache.ko and clockpro_cache.ko).

The flow is as follows:

1. Each module, when loaded, creates a virtual file in the /proc filesystem (e.g., /proc/lru_cache_sim).

2. A trace-replay is performed by writing a text file (the "workload") containing space-separated page IDs to this /proc file.

3. The module's proc_write function parses this trace, runs its internal cache simulation (using a hash table for lookups and linked lists for eviction), and processes every page access.

4. After the trace is complete, the module prints the final statistics (Total Accesses, Hits, Hit Ratio) to the kernel log, which can be viewed with dmesg.

# How to Use

# 1. Prerequisites

You must be on a Linux system with the kernel headers and build tools installed.

For Debian/Ubuntu-based systems:

-> sudo apt-get update
-> sudo apt-get install build-essential linux-headers-$(uname -r)


For Fedora/CentOS-based systems:

-> sudo dnf install kernel-devel kernel-headers make gcc


# 2. Compilation

Clone the repository and run make:

-> make clean
-> make


This will produce lru_cache.ko and clockpro_cache.ko.

# 3. Running the Simulation

You must load, test, and unload each module one at a time.

Example: Testing LRU with mixed_trace.txt

1. Load the LRU module
-> sudo insmod lru_cache.ko

2. Run the trace-replay
(We use 'sh -c' to handle the privileged redirection)
-> sudo sh -c 'cat mixed_trace.txt > /proc/lru_cache_sim'

3. View the results
-> dmesg | tail -n 5

4. Unload the module
-> sudo rmmod lru_cache


Example: Testing CLOCK-Pro with mixed_trace.txt

1. Load the CLOCK-Pro module
-> sudo insmod clockpro_cache.ko

2. Run the trace-replay
-> sudo sh -c 'cat mixed_trace.txt > /proc/clockpro_cache_sim'

3. View the results
-> dmesg | tail -n 5

4. Unload the module
-> sudo rmmod clockpro_cache


# Workloads

This project includes four key workloads to test different scenarios (with a CACHE_SIZE of 128):

1. working_set_trace.txt (Ideal Case):

What it is: A small, 60-page loop repeated many times.

Tests: Correctness. Both algorithms should achieve a near-perfect hit ratio.

2. mixed_trace.txt (Scan Pollution Test):

What it is: A small hot set (pages 1-10) mixed with a large, 128-page scan (pages 100-227).

Tests: Scan resistance. CLOCK-Pro should have a much higher hit ratio.

3. thrashing_trace.txt (Worst-Case):

What it is: A 129-page loop (just larger than the cache).

Tests: Thrashing. Both algorithms should fail with a 0% hit ratio, as the cache is fundamentally too small.

4. shift_trace.txt (Adaptability Test):

What it is: A trace that establishes one hot set, then suddenly and permanently switches to a new one.

Tests: How quickly the cache "forgets" old data. LRU's simplicity may give it a slight edge in adaptation speed.

# Expected Results

This project will empirically demonstrate the performance trade-offs of these algorithms. The graph generated by plot_results.py clearly shows CLOCK-Pro's superiority in scan-heavy environments.

